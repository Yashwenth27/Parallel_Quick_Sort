<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel Quicksort with CUDA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .section {
            min-height: 100vh;
            padding-top: 80px; /* Offset for sticky nav */
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.8s ease-out forwards;
        }
        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .slide-in-left {
            animation: slideInLeft 0.8s ease-out forwards;
        }
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .slide-in-right {
            animation: slideInRight 0.8s ease-out forwards;
        }
        .flowchart-box {
            @apply text-center p-4 border-2 rounded-lg shadow-lg text-sm md:text-base;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .code-block {
            background-color: #1a202c;
            color: #e2e8f0;
            font-family: 'SF Mono', 'Courier New', Courier, monospace;
            white-space: pre;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .explanation-box {
            background-color: #2d3748;
        }
        .code-line {
            transition: background-color 0.5s ease;
        }
        .line-highlight {
            background-color: rgba(59, 130, 246, 0.3);
            border-left: 2px solid #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Sticky Navigation -->
    <nav class="sticky top-0 z-50 bg-gray-900 bg-opacity-80 backdrop-blur-md shadow-lg">
        <div class="container mx-auto px-6 py-3 flex justify-between items-center">
            <div class="text-xl font-bold text-white">Quicksort Explainer</div>
            <div class="hidden md:flex space-x-6">
                <a href="#problem" class="text-gray-300 hover:text-green-400">The Problem</a>
                <a href="#algorithm" class="text-gray-300 hover:text-green-400">Algorithm</a>
                <a href="#flowchart" class="text-gray-300 hover:text-green-400">Flowchart</a>
                <a href="#code" class="text-gray-300 hover:text-green-400">Code Explained</a>
                <a href="#conclusion" class="text-gray-300 hover:text-green-400">Conclusion</a>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="title" class="section flex flex-col items-center justify-center text-center p-8 bg-cover bg-center -mt-[68px]" style="background-image: linear-gradient(rgba(17, 24, 39, 0.8), rgba(17, 24, 39, 0.8)), url('https://placehold.co/1920x1080/111827/374151?text=GPU+Cores');">
        <h1 class="text-5xl md:text-7xl font-bold text-white tracking-tight fade-in">Parallel Quicksort with CUDA</h1>
        <p class="mt-4 text-xl md:text-2xl text-gray-300 fade-in" style="animation-delay: 0.2s;">Using a Global Stack for Dynamic Work Distribution</p>
        <div class="mt-8 h-2 w-32 bg-green-500 rounded-full fade-in" style="animation-delay: 0.4s;"></div>
    </section>

    <!-- Section 2: The Problem -->
    <section id="problem" class="section flex items-center justify-center p-8 bg-gray-800">
        <div class="container mx-auto grid md:grid-cols-2 gap-12 items-center">
            <div class="slide-in-left">
                <h2 class="text-4xl font-bold text-white mb-6">The Problem: Why Parallel Sorting?</h2>
                <ul class="space-y-4 text-lg text-gray-300">
                    <li><span class="text-green-400 font-semibold">Fundamental Task:</span> Sorting is a core computing operation.</li>
                    <li><span class="text-green-400 font-semibold">The Bottleneck:</span> For massive datasets, single-core CPU sorting is too slow.</li>
                    <li><span class="text-green-400 font-semibold">The Goal:</span> Leverage thousands of GPU cores to sort data dramatically faster.</li>
                    <li><span class="text-green-400 font-semibold">The Challenge:</span> How do we efficiently divide the work and keep all cores busy?</li>
                </ul>
            </div>
            <div class="slide-in-right flex flex-col items-center justify-center space-y-8">
                <div class="text-center">
                    <div class="w-32 h-32 bg-blue-600 rounded-lg flex items-center justify-center shadow-2xl">
                        <span class="font-bold text-white">CPU Core</span>
                    </div>
                    <p class="mt-2 font-semibold">Single, Powerful Core</p>
                </div>
                <div class="text-center">
                     <div class="grid grid-cols-4 gap-2">
                        <div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div><div class="w-10 h-10 bg-green-500 rounded"></div>
                     </div>
                     <p class="mt-2 font-semibold">GPU (Thousands of Cores)</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 3: The Algorithm -->
    <section id="algorithm" class="section flex items-center justify-center p-8 bg-gray-900">
        <div class="container mx-auto grid md:grid-cols-2 gap-12 items-center">
            <div class="slide-in-left">
                <h2 class="text-4xl font-bold text-white mb-6">The Algorithm: A "To-Do List" Approach</h2>
                <p class="text-lg text-gray-300 mb-4">We use a "divide and conquer" strategy with a shared to-do list, called a **stack**.</p>
                <ol class="list-decimal list-inside space-y-3 text-lg text-gray-300">
                    <li>Start with one task: "Sort the whole array".</li>
                    <li>A thread grabs a task and **partitions** the array.</li>
                    <li>It adds the <span class="font-bold text-yellow-400">LARGER</span> new part back to the to-do list.</li>
                    <li>It immediately works on the <span class="font-bold text-blue-400">SMALLER</span> part.</li>
                </ol>
                <p class="mt-4 text-xl font-semibold text-green-400">This "work-stealing" model keeps all threads busy automatically!</p>
            </div>
            <div class="slide-in-right p-6 bg-gray-800 rounded-xl shadow-2xl">
                <h3 class="text-center font-bold text-xl mb-4">GPU To-Do List (Stack)</h3>
                <div class="space-y-3">
                    <div class="bg-yellow-500 text-gray-900 p-4 rounded-lg shadow-lg text-center font-semibold">Task: Sort [N - Z]</div>
                    <div class="bg-yellow-400 text-gray-900 p-4 rounded-lg shadow-lg text-center font-semibold">Task: Sort [M - P]</div>
                    <div class="bg-gray-700 p-4 rounded-lg shadow-inner text-center text-gray-400">... more tasks ...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 4: Flowchart -->
    <section id="flowchart" class="section flex flex-col items-center justify-center p-8 bg-gray-800">
        <h2 class="text-4xl font-bold text-white mb-12 text-center">Algorithm Flowchart</h2>
        <div class="w-full max-w-5xl">
            <div class="flex flex-col items-center space-y-8">
                <div class="flowchart-box bg-green-600 border-green-400 w-48">Start</div>
                <div class="h-8 border-l-2 border-gray-600"></div>
                <div class="flowchart-box bg-blue-600 border-blue-400 w-64">Thread grabs task from Global Stack</div>
                <div class="h-8 border-l-2 border-gray-600"></div>
                <div class="flowchart-box bg-yellow-500 border-yellow-300 w-56">Is subarray large?</div>
                <div class="w-full flex justify-center relative">
                    <div class="absolute top-0 h-px w-2/3 bg-gray-600"></div>
                    <div class="absolute top-0 left-[16.67%] w-px h-8 bg-gray-600"></div>
                    <div class="absolute top-0 right-[16.67%] w-px h-8 bg-gray-600"></div>
                </div>
                <div class="w-full grid grid-cols-2 gap-32 pt-8">
                    <div class="text-center">
                        <p class="font-bold mb-2 text-red-400">No</p>
                        <div class="flowchart-box bg-purple-600 border-purple-400 w-64 mx-auto">Insertion Sort (Finish Task)</div>
                    </div>
                    <div class="text-center">
                        <p class="font-bold mb-2 text-green-400">Yes</p>
                        <div class="flowchart-box bg-purple-600 border-purple-400 w-64 mx-auto">Partition Array</div>
                        <div class="h-8 border-l-2 border-gray-600 mx-auto w-0"></div>
                        <div class="flowchart-box bg-blue-600 border-blue-400 w-64 mx-auto">Push larger part to Stack & Process smaller part</div>
                        <div class="mt-4 text-gray-400">...then loop back to grab next task</div>
                    </div>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Section 5: Code Explained -->
    <section id="code" class="section flex flex-col items-center justify-start p-8 bg-gray-900">
        <h2 class="text-4xl font-bold text-white mb-8 text-center">Code Explained: A Line-by-Line Walkthrough</h2>
        <div class="container mx-auto space-y-8">

            <!-- Block 1: Headers & Config -->
            <div class="grid md:grid-cols-2 gap-4">
                <div class="code-block p-4 rounded-lg"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
// ... other includes

#define INSERTION_SORT_THRESHOLD 32
#define STACK_SIZE 1024

struct SubArray {
    int low;
    int high;
};</code></div>
                <div class="explanation-box p-6 rounded-lg">
                    <h3 class="font-bold text-xl text-green-400 mb-2">Part 1: Setup & Configuration</h3>
                    <p>This initial block sets up the environment and defines key constants and data structures.</p>
                </div>
            </div>

            <!-- Block 2: Device Helpers -->
            <div class="grid md:grid-cols-2 gap-4">
                <div class="code-block p-4 rounded-lg"><code>__device__ void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

__device__ void insertion_sort(...) { ... }

__device__ int partition(...) { ... }</code></div>
                <div class="explanation-box p-6 rounded-lg">
                    <h3 class="font-bold text-xl text-green-400 mb-2">Part 2: Device Helper Functions</h3>
                    <p>These `__device__` functions are the tools each GPU thread uses to perform the sort.</p>
                </div>
            </div>
            
            <!-- Block 3: The Full Kernel with Dry Run -->
            <div class="grid md:grid-cols-2 gap-4">
                <div id="kernel-code-block" class="code-block p-4 rounded-lg"><code><div id="line-0" class="code-line">__global__ void parallel_quicksort_kernel(...) {</div><div id="line-1" class="code-line">    while (*sorted_count < n) {</div><div id="line-2" class="code-line">        int pos = atomicSub(stack_top, 1);</div><div id="line-3" class="code-line">        </div><div id="line-4" class="code-line">        if (pos > 0) {</div><div id="line-5" class="code-line">            SubArray task = stack[pos - 1];</div><div id="line-6" class="code-line">            int low = task.low;</div><div id="line-7" class="code-line">            int high = task.high;</div><div id="line-8" class="code-line">            </div><div id="line-9" class="code-line">            while (low < high) {</div><div id="line-10" class="code-line">                if ((high-low+1) < THRESHOLD) {</div><div id="line-11" class="code-line">                    insertion_sort(arr, low, high);</div><div id="line-12" class="code-line">                    atomicAdd(sorted_count, ...);</div><div id="line-13" class="code-line">                    break; </div><div id="line-14" class="code-line">                }</div><div id="line-15" class="code-line">                </div><div id="line-16" class="code-line">                int pivot = partition(arr, low, high);</div><div id="line-17" class="code-line">                atomicAdd(sorted_count, 1);</div><div id="line-18" class="code-line">                </div><div id="line-19" class="code-line">                if (left_size > right_size) {</div><div id="line-20" class="code-line">                    atomicAdd(stack_top, 1);</div><div id="line-21" class="code-line">                    low = pivot + 1;</div><div id="line-22" class="code-line">                } else { ... }</div><div id="line-23" class="code-line">            }</div><div id="line-24" class="code-line">            if(low == high) { ... }</div><div id="line-25" class="code-line">        }</div><div id="line-26" class="code-line">    }</div><div id="line-27" class="code-line">}</div></code></div>
                <div class="explanation-box p-6 rounded-lg">
                    <div class="flex justify-between items-center">
                        <h3 class="font-bold text-xl text-green-400">Part 3: Kernel Live Dry Run</h3>
                        <button id="restart-animation-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded text-sm">Restart</button>
                    </div>
                    <p class="text-sm my-4">This animation shows how threads execute the kernel logic on a 7-element array.</p>
                    
                    <div id="dryRunThread" class="font-bold text-yellow-300 text-lg"></div>
                    <div class="mt-2">
                        <h4 class="font-semibold text-sm">Array State:</h4>
                        <div id="dryRunArray" class="flex flex-wrap gap-1 mt-1"></div>
                    </div>
                    <div class="mt-2">
                        <h4 class="font-semibold text-sm">Stack State:</h4>
                        <div id="dryRunStack" class="space-y-1 mt-1 text-sm"></div>
                    </div>
                    <div class="mt-4 bg-gray-900 p-3 rounded">
                        <p class="text-sm text-cyan-300" id="dryRunDescription"></p>
                    </div>
                </div>
            </div>

            <!-- Block 4: The Host 'main' function -->
            <div class="grid md:grid-cols-2 gap-4">
                <div class="code-block p-4 rounded-lg"><code>int main() {
    const int N = 1 &lt;&lt; 10;
    std::vector&lt;int&gt; h_arr(N);
    // ... initialize data ...
    
    // Sort on CPU for validation
    std::sort(h_cpu_sorted.begin(), h_cpu_sorted.end());

    // Allocate memory on GPU
    int* d_arr;
    cudaMalloc((void**)&d_arr, N * sizeof(int));
    // ... malloc stack, etc. ...

    // Copy data from Host to Device
    cudaMemcpy(d_arr, h_arr.data(), ..., cudaMemcpyHostToDevice);

    // Launch the Kernel on the GPU
    parallel_quicksort_kernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(...);
    
    // Copy sorted data from Device to Host
    cudaMemcpy(h_gpu_result.data(), d_arr, ..., cudaMemcpyDeviceToHost);

    // Validate and clean up
    cudaFree(d_arr);
    return 0;
}</code></div>
                <div class="explanation-box p-6 rounded-lg">
                    <h3 class="font-bold text-xl text-green-400 mb-2">Part 4: The Host (CPU Control)</h3>
                    <p>The `main` function runs on the CPU and manages the entire process from start to finish.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 6: Conclusion -->
    <section id="conclusion" class="section flex flex-col items-center justify-center text-center p-8 bg-gray-800">
        <h2 class="text-4xl font-bold text-white mb-6">Performance & Conclusion</h2>
        <div class="max-w-3xl mx-auto space-y-8">
            <div>
                <h3 class="text-2xl font-semibold text-green-400 mb-2">Results</h3>
                <p class="text-lg text-gray-300">For small arrays (N < 100,000), CPU can be faster due to data transfer overhead. For large arrays, the GPU's parallelism provides a massive speedup.</p>
            </div>
            <div>
                <h3 class="text-2xl font-semibold text-green-400 mb-2">Conclusion</h3>
                <p class="text-lg text-gray-300">The global stack model is a powerful technique for **dynamic load balancing** in parallel algorithms. CUDA unlocks the massive power of GPUs for general-purpose tasks like sorting, making large-scale data processing feasible.</p>
            </div>
        </div>
    </section>

<script>
    const dryRunThread = document.getElementById('dryRunThread');
    const dryRunArray = document.getElementById('dryRunArray');
    const dryRunStack = document.getElementById('dryRunStack');
    const dryRunDescription = document.getElementById('dryRunDescription');
    const kernelCodeBlock = document.getElementById('kernel-code-block');
    const codeLines = kernelCodeBlock.querySelectorAll('.code-line');
    const restartBtn = document.getElementById('restart-animation-btn');

    const dryRunSteps = [
        { thread: "Thread A", line: 2, array: [8, 3, 1, 7, 0, 10, 2], stack: [{low: 0, high: 6}], desc: "Grabs the initial task [0-6] from the stack." },
        { thread: "Thread A", line: 16, array: [8, 3, 1, 7, 0, 10, 2], stack: [], desc: "Partitions with pivot 2. Array becomes [1, 0, 2, 7, 8, 10, 3]." },
        { thread: "Thread A", line: 17, array: [1, 0, 2, 7, 8, 10, 3], stack: [], desc: "Pivot 2 is now sorted. Increment sorted count.", highlights: [{index: 2}] },
        { thread: "Thread A", line: 20, array: [1, 0, 2, 7, 8, 10, 3], stack: [{low: 3, high: 6}], desc: "Pushes larger right part [3-6] to stack.", highlights: [{index: 2}] },
        { thread: "Thread A", line: 21, array: [1, 0, 2, 7, 8, 10, 3], stack: [{low: 3, high: 6}], desc: "Loops to process smaller left part [0-1].", highlights: [{index: 2}] },
        { thread: "Thread B", line: 2, array: [1, 0, 2, 7, 8, 10, 3], stack: [{low: 3, high: 6}], desc: "An idle thread (B) grabs task [3-6] from the stack.", highlights: [{index: 2}] },
        { thread: "Thread A", line: 11, array: [0, 1, 2, 7, 8, 10, 3], stack: [], desc: "Thread A's task [0-1] is small, so it uses insertion_sort.", highlights: [{index: 2}] },
        { thread: "Thread A", line: 12, array: [0, 1, 2, 7, 8, 10, 3], stack: [], desc: "Adds 2 to sorted_count. Thread A is now free.", highlights: [0, 1, 2].map(i => ({index: i})) },
        { thread: "Thread B", line: 16, array: [0, 1, 2, 7, 8, 10, 3], stack: [], desc: "Thread B partitions its task [3-6] with pivot 3.", highlights: [0, 1, 2].map(i => ({index: i})) },
        { thread: "Thread B", line: 17, array: [0, 1, 2, 3, 8, 10, 7], stack: [], desc: "Pivot 3 is sorted. Increment sorted count.", highlights: [0, 1, 2, 3].map(i => ({index: i})) },
        { thread: "Thread B", line: 20, array: [0, 1, 2, 3, 8, 10, 7], stack: [{low: 4, high: 6}], desc: "Pushes new task [4-6] to stack. Thread B is free.", highlights: [0, 1, 2, 3].map(i => ({index: i})) },
        { thread: "Thread C", line: 2, array: [0, 1, 2, 3, 8, 10, 7], stack: [{low: 4, high: 6}], desc: "A free thread (C) grabs task [4-6].", highlights: [0, 1, 2, 3].map(i => ({index: i})) },
        { thread: "Thread C", line: 16, array: [0, 1, 2, 3, 7, 10, 8], stack: [], desc: "Partitions [4-6] with pivot 8. Pivot is sorted.", highlights: [0, 1, 2, 3, 6].map(i => ({index: i})) },
        { thread: "Thread C", line: 20, array: [0, 1, 2, 3, 7, 10, 8], stack: [{low: 4, high: 5}], desc: "Pushes new task [4-5] to stack. Thread C is free.", highlights: [0, 1, 2, 3, 6].map(i => ({index: i})) },
        { thread: "Thread D", line: 11, array: [0, 1, 2, 3, 7, 8, 10], stack: [], desc: "A free thread sorts small task [4-5].", highlights: [0, 1, 2, 3, 6].map(i => ({index: i})) },
        { thread: "All Done", line: 1, array: [0, 1, 2, 3, 7, 8, 10], stack: [], desc: "Stack is empty. All elements are sorted!", highlights: [0, 1, 2, 3, 4, 5, 6].map(i => ({index: i})) }
    ];

    let currentDryRunStep = 0;
    let animationInterval;

    function renderDryRunStep(stepIndex) {
        const step = dryRunSteps[stepIndex];
        
        dryRunThread.textContent = `Active Thread: ${step.thread}`;
        dryRunDescription.textContent = step.desc;

        dryRunArray.innerHTML = '';
        step.array.forEach((val, i) => {
            const el = document.createElement('div');
            el.className = 'w-8 h-8 flex items-center justify-center rounded text-white text-xs font-bold transition-all duration-500';
            const isHighlighted = step.highlights && step.highlights.some(h => h.index === i);
            el.classList.add(isHighlighted ? 'bg-green-600' : 'bg-gray-700');
            el.textContent = val;
            dryRunArray.appendChild(el);
        });

        dryRunStack.innerHTML = '';
        if (step.stack.length === 0) {
            dryRunStack.innerHTML = '<div class="bg-gray-700 text-gray-400 p-1 rounded text-center">[Empty]</div>';
        } else {
            step.stack.forEach(task => {
                const el = document.createElement('div');
                el.className = 'bg-yellow-500 text-gray-900 p-1 rounded text-center font-semibold';
                el.textContent = `Sort [${task.low} - ${task.high}]`;
                dryRunStack.appendChild(el);
            });
        }
        
        codeLines.forEach(line => line.classList.remove('line-highlight'));
        if (document.getElementById(`line-${step.line}`)) {
            document.getElementById(`line-${step.line}`).classList.add('line-highlight');
        }
    }

    function startAnimation() {
        clearInterval(animationInterval);
        currentDryRunStep = 0;
        renderDryRunStep(0);
        animationInterval = setInterval(() => {
            currentDryRunStep = (currentDryRunStep + 1) % dryRunSteps.length;
            renderDryRunStep(currentDryRunStep);
        }, 2500);
    }

    restartBtn.addEventListener('click', startAnimation);

    startAnimation();
</script>

</body>
</html>
